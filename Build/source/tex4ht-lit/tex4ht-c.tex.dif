diff -r 09d75947f4a5 lit/tex4ht-c.tex
--- a/lit/tex4ht-c.tex	Tue Aug 29 13:45:07 2017 +0300
+++ b/lit/tex4ht-c.tex	Thu Oct 19 13:00:57 2017 +0300
@@ -1513,14 +1513,15 @@
 \<trace context\><<<
 {
   char trace = *(p+2);
-  if (trace == 'A' || trace == 'e') { `<context for warn and errs`> }
-  if (trace == 'A' || trace == 'f') { `<dump htf files`> }
-  if (trace == 'A' || trace == 'F') { `<trace htf search`> }
-  if (trace == 'A' || trace == 's') { `<trace specials in dvi`> }
-  if (trace == 'A' || trace == 'g') { `<cmd line trace groups`> }
-  if (trace == 'A' || trace == 'v') { `<dump env file`> }
-  if (trace == 'A' || trace == 'V') { `<trace env search`> }
-  else { bad_arg; }
+  BOOL unkn_opt = TRUE;
+  if (trace == 'A' || trace == 'e') { `<context for warn and errs`> unkn_opt = FALSE; }
+  if (trace == 'A' || trace == 'f') { `<dump htf files`> unkn_opt = FALSE; }
+  if (trace == 'A' || trace == 'F') { `<trace htf search`> unkn_opt = FALSE; }
+  if (trace == 'A' || trace == 's') { `<trace specials in dvi`> unkn_opt = FALSE; }
+  if (trace == 'A' || trace == 'g') { `<cmd line trace groups`> unkn_opt = FALSE; }
+  if (trace == 'A' || trace == 'v') { `<dump env file`> unkn_opt = FALSE; }
+  if (trace == 'A' || trace == 'V') { `<trace env search`> unkn_opt = FALSE; }
+  if (unkn_opt) { bad_arg; }
 }
 >>>
 
@@ -2822,7 +2823,7 @@
 \<trace h spaces\><<<
 if( trace_dvi_H && !ch_map_flag ){
    if( *trace_dvi_del_H != '\0' ){
-      (IGNORED) fprintf(cur_o_file, "%s%d", trace_dvi_del_H, (int) dx);
+      (IGNORED) fprintf(cur_o_file, "%s%.0f", trace_dvi_del_H, dx);
    }
    (IGNORED) fprintf(cur_o_file, "%s", end_trace_dvi_del_H);
 }
@@ -3083,7 +3084,8 @@
 `[ 
 static INTEGER move_x( d ) 
       register INTEGER  d
-;{    register long     i, dx;
+;{    register long     i;
+      double dx, sp;
    x_val += d;
    if( (x_val > max_x_val) && x_val ){
      if( max_x_val == -10000) max_x_val = x_val - d;  
@@ -3127,7 +3129,9 @@
 
 \<space for llap\><<<
 if( !ignore_spaces ){
-   i =  (INTEGER) ( (double) (dx = d) / word_sp + 0.5 );
+   i = 0;
+   if (word_sp > 0.0001)
+      i =  (INTEGER) ( (dx = d) / word_sp + 0.5 );
    if( i<0 ) i=0;
    if( !i ) i = dx>99999L;
    if( i ){ put_char(' '); }
@@ -3235,8 +3239,11 @@
 
 
 \<insert space\><<<
-i =  (INTEGER) (  (double) (dx = x_val - max_x_val) 
-            /         (text_on? word_sp : margin_sp)
+i = 0;
+sp = (text_on? word_sp : margin_sp);
+if (sp > 0.0001)
+    i =  (INTEGER) (  (dx = (double)x_val - (double)max_x_val) 
+            /         sp
             +         0.5 );
 `<try word space if i=0`>
 if( i<0 ) i=0;
@@ -3251,7 +3258,8 @@
 
 \<try word space if i=0\><<<
 if( i==0 ){
-   i =  (INTEGER) (  (double) dx 
+   if (word_sp > 0.0001)
+      i =  (INTEGER) (dx 
             /         word_sp 
             +         0.5 );
 }
@@ -3481,12 +3489,16 @@
 
 \<check alternative space\><<<
          double word_sp;
+         double sp;
 cr_fnt = ch - `<font 0`>;
 cr_fnt = search_font_tbl( cr_fnt );
 word_sp = design_size_to_pt( font_tbl[cr_fnt].word_sp )
              * (double) font_tbl[cr_fnt].scale;
-i =  (INTEGER) (  (double) dx
-            /         (text_on? word_sp : margin_sp)
+i = 0;
+sp = (text_on? word_sp : margin_sp);
+if (sp > 0.0001)
+    i =  (INTEGER) (  dx
+            /         sp
             +         0.5 );
 `<try word space if i=0`>
 if( i>0 ){ i =1; }
@@ -3706,10 +3718,14 @@
           || ( !text_on && !ignore_chs )
         )
 ){ 
+   double sp;
    if( (max_x_val == -10000) || ((x_val + right) <= max_x_val) )
    {  max_x_val = x_val;  }        
-   i =  (INTEGER) (  (double) (x_val + right - max_x_val) 
-                   /         (text_on? word_sp : margin_sp)
+   i = 0;
+   sp = (text_on? word_sp : margin_sp);
+   if (sp > 0.0001)
+      i =  (INTEGER) (  (double) (x_val + right - max_x_val) 
+                   /         sp
                    +         0.5 );
    `<try word size if i=0`>
    if( i && !text_on )  try_new_line();
@@ -3727,7 +3743,8 @@
 
 \<try word size if i=0\><<<
 if( i==0 ){
-   i =  (INTEGER) (  (double) (x_val + right - max_x_val) 
+   if (word_sp > 0.0001)
+      i =  (INTEGER) (  (double) (x_val + right - max_x_val) 
                    /         word_sp
                    +         0.5 );
 }
@@ -5854,7 +5871,7 @@
 case `<def 3 byte font`>: 
 case `<def 2 byte font`>: 
 case `<def 1 byte font`>: {  idv_char( ch );             file_n++;
-  for( i=14; i; i-- ){  ch = get_char(); idv_char( ch ); file_n++; }
+  for( i=14 + ch - 243; i; i-- ){  ch = get_char(); idv_char( ch ); file_n++; }
   i = ch;  i += ch = get_char();  idv_char( ch );        file_n++;
   while( i-- ){ idv_copy(); }
   break;  }
@@ -7552,7 +7569,7 @@
 \<send back over token / group\><<<
               struct send_back_entry *p, *q, *t=0;
 if( back_id_off ){
-   while( i-- ){ (IGNORED) get_char();  }
+   while( --i ){ (IGNORED) get_char();  } // there are left i - 1 chars
 } else {
    p =  m_alloc(struct send_back_entry,1);
    p->send = get_str( (int)( i - 1 ));
@@ -8670,6 +8687,9 @@
                  (size_t) ((font_tbl_size+1)
                            * sizeof(struct font_entry)))
             : m_alloc(struct font_entry, 1);
+
+   memset(&new_font, 0, sizeof(struct font_entry));
+
    if(       (version_id == `<version xdv`>) 
          &&  (ch == `<xdv-native-font-def op`>) 
    ){
@@ -9295,7 +9315,7 @@
 
 \<first definition of font?\><<<
 {        int i;
-   for( i=font_tbl_size-1; i>0;  i-- )
+   for( i=font_tbl_size-1; i >= 0;  i-- )
      if( new_font.num == font_tbl[i].num )  warn_i(10);   }
 >>>
 
@@ -10054,9 +10074,12 @@
   while( 1 ){                         BOOL flag;
      `<font looping test`>
      flag = TRUE;
-     for( ; font_name_n; font_name_n-- ){  FILE* file;
+     for( ; font_name_n >= 0; font_name_n-- ){  FILE* file;
                                            int   char_f, char_l;
        new_font_name[font_name_n] = '\0';
+       if (font_name_n == 0)
+            break;
+
        `<file = .htf file`>
        if( file != NULL){
                                            INTEGER x_char_l;
@@ -11878,9 +11901,12 @@
      int css_name_n = (int) strlen((char *)  new_font.name );
      char * css_file_name = m_alloc(char, css_name_n + 1);
      (IGNORED) strcpy((char *) css_file_name, (char *) new_font.name);
-     for( ; css_name_n; css_name_n-- ){
+     for( ; css_name_n >= 0; css_name_n-- ){
                                                FILE* file;
        css_file_name[css_name_n] = '\0';
+       if (css_name_n == 0)
+            break;
+
        `<file = .css file`>
      }
      free((void *) css_file_name); 
@@ -15389,18 +15415,20 @@
 ;{                                         U_CHAR  *p;
    p = m_alloc(char, (int) strlen( dir )            +
                      (base? (int) strlen( base ):0) +
-                     (int) strlen((char *)  HOME_DIR  )      + 1 );
+                     (HOME_DIR? (int) strlen((char *)  HOME_DIR  ) : 0)      + 1 );
    *p = '\0';    
    if( (*(dir+1) == '~') && base ){  
      if( *base == '~' ){  
-       (IGNORED) strct(p, HOME_DIR);   
+       if (HOME_DIR)
+            (IGNORED) strct(p, HOME_DIR);   
        (IGNORED) strct(p, base+1);   
      } else {
        (IGNORED) strct(p, base);   
      } 
      (IGNORED) strct(p, dir+2);   
    } else {
-     (IGNORED) strct(p, HOME_DIR);   
+     if (HOME_DIR)
+            (IGNORED) strct(p, HOME_DIR);   
      (IGNORED) strct(p, dir+1);   
    }
    return p;
